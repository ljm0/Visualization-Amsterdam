<!DOCTYPE html>
<html lang="en">

<head>            
    <meta charset="utf-8">
    <title>IV: Group11</title>
    <script src="https://d3js.org/d3.v5.js"></script>
    <style>
        path {
            fill: none;
            stroke-width: 1px;
            stroke: #222;
        }
    </style>
</head>

<body>
    <svg width="800" height="600">
        <g id="mapLayer"></g>
    </svg>
    <script type="text/javascript">
        async function choropleth() {
            let svg = d3.select("svg");
            let width = parseInt(svg.attr("width"));
            let height = parseInt(svg.attr("height"));

            let projection = d3.geoAlbers() 
                .center([4.9, 52.366667])
                .parallels([51.5, 51.49])
                .rotate(120)
                .scale(210000)
                .translate([width / 2, height / 2]);

            let path = d3.geoPath()
                .projection(projection);

            // Define a quantized scale to sort data values into buckets of color
            let color = d3.scaleQuantize()
                .range(["#edf8fb",
                    "#b2e2e2",
                    "#66c2a4",
                    "#2ca25f",
                    "#006d2c"
                ]);


            // Load in GeoJSON data
            let json = await d3.json("map.geojson");


            // Load in the agriculture data; 
            let livingData = await d3.csv("score.csv");

            // Set input domain for color scale based on the lowest and highest values in the data
            color.domain([
                d3.min(livingData, function (d) {
                    return d.living_condition_score_2017;
                }),
                d3.max(livingData, function (d) {
                    return d.living_condition_score_2017;
                })
            ]);

            // Convert the data array to an object, so that it's easy to look up
            // data scores by district names
            let dataLookup = {};
            livingData.forEach(function (scoreRow) {
                // d3.csv will read the values as strings; we need to convert them to floats
                dataLookup[scoreRow.district] = parseFloat(scoreRow.living_condition_score_2017);
            });

            // Now we add the data values to the geometry for every district
            json.features.forEach(function (feature) {
                feature.properties.score = dataLookup[feature.properties.district];
            });

            // Bind data and create one path per GeoJSON feature
            d3.select("#mapLayer").selectAll("path")
                .data(json.features)
                .enter()
                .append("path")
                // here we use the familiar d attribute again to define the path
                .attr("d", path)
                .style("fill", function (d) {
                    return color(d.properties.score);
                });

        };
        choropleth();
    </script>
</body>

</html>