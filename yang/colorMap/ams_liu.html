<!DOCTYPE html>
<html lang="en">

<head>            
    <meta charset="utf-8">
    <title>IV: Group11</title>
    <script src="https://d3js.org/d3.v5.js"></script>
    <style>
        path {
            fill: none;
            stroke-width: 1px;
            stroke: #222;
        }
      .keys.selected {
        font-weight: bold;
      }
      #tooltip {
        position: absolute;
        top: 0;
        left: 0;
        background-color: #f0f0f0;
      }
    </style>
</head>

<body>
    <svg width="800" height="600">
        <g id="mapLayer"></g>
    </svg>
    <script type="text/javascript">
        async function choropleth() {
            let svg = d3.select("svg");
            let width = parseInt(svg.attr("width"));
            let height = parseInt(svg.attr("height"));

            let projection = d3.geoAlbers() 
                .center([4.9, 52.366667])
                .parallels([51.5, 51.49])
                .rotate(120)
                .scale(210000)
                .translate([width / 2, height / 2]);

            let path = d3.geoPath()
                .projection(projection);

            // Define a quantized scale to sort data values into buckets of color
            let color = d3.scaleQuantize()
                .range(["#edf8fb",
                    "#b2e2e2",
                    "#66c2a4",
                    "#2ca25f",
                    "#006d2c"
                ]);


            // Load in GeoJSON data
            let json = await d3.json("map.geojson");


            // Load in the agriculture data; 
            let livingData = await d3.csv("score.csv");

            // Set input domain for color scale based on the lowest and highest values in the data
            color.domain([
                d3.min(livingData, function (d) {
                    return d.living_condition_score_2017;
                }),
                d3.max(livingData, function (d) {
                    return d.living_condition_score_2017;
                })
            ]);

            // Convert the data array to an object, so that it's easy to look up
            // data scores by district names
            let dataLookup = {};
            livingData.forEach(function (scoreRow) {
                // d3.csv will read the values as strings; we need to convert them to floats
                dataLookup[scoreRow.district] = parseFloat(scoreRow.living_condition_score_2017);
            });

            // Now we add the data values to the geometry for every district
            json.features.forEach(function (feature) {
                feature.properties.score = dataLookup[feature.properties.district];
            });

            var tooltip = d3.select("body")
                .append("div")
                .attr("id", "tooltip")
                .style("opacity", 0);
            // Bind data and create one path per GeoJSON feature
            d3.select("#mapLayer").selectAll("path")
                .data(json.features)
                .enter()
                .append("path")
                // here we use the familiar d attribute again to define the path
                .attr("d", path)
                .style("fill", function (d) {
                    return color(d.properties.score);
                })
                // .attr('ken', function (d) {
                //     return d.properties.score;
                // })
                .style('cursor', 'pointer')
                .on('mouseover', function (d) {
                    tooltip.style("opacity", 1)
                .html(d.properties.district + '<br />'+ "living condition score: "+d.properties.score )
                        .style("left", (d3.event.pageX + 10) + "px")
                        .style("top", (d3.event.pageY - 40) + "px");
                    var self = d3.select(this);
                    self.style('fill', 'blue');
                })
                .on('mousemove', function (d) {
                    tooltip
                        .style("left", (d3.event.pageX + 10) + "px")
                        .style("top", (d3.event.pageY - 40) + "px");
                })
                .on('mouseout', function (d, i) {
                    tooltip.style("opacity", 0);

                    var self = d3.select(this);
                    self.transition()
                        .duration(300)
                        .style('fill', function (d, i) {
                            return color(d.properties.score);
                        });
                });

        };
        choropleth();
    </script>
</body>

</html>